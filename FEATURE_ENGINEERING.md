# 特征工程说明文档

## 📊 特征工程概述

在原有的深度学习模型基础上，我们添加了 **19个手工特征**，通过特征融合来提升模型性能。

### 🎯 为什么需要特征工程？

1. **互补性**：深度学习善于学习抽象特征，但某些显式的统计特征可能被忽略
2. **可解释性**：手工特征更直观，便于理解模型决策
3. **稳定性**：统计特征在小样本上更稳定
4. **性能提升**：在文本匹配任务中，特征工程通常能带来1-3%的AUC提升

---

## 🔧 提取的19个特征

### 1️⃣ 长度特征（4个）

| 特征名 | 说明 | 意义 |
|--------|------|------|
| `len_q1` | 文本1的词数 | 文本长度信息 |
| `len_q2` | 文本2的词数 | 文本长度信息 |
| `len_diff` | 长度差的绝对值 | 长度差异越大，越可能不匹配 |
| `len_ratio` | 长度比（min/max） | 比值越接近1，长度越相近 |

### 2️⃣ 词重叠特征（3个）

| 特征名 | 说明 | 意义 |
|--------|------|------|
| `word_overlap_count` | 共同词的数量 | 重叠越多，越可能匹配 |
| `word_overlap_ratio` | 重叠词占比 | 标准化的重叠度 |
| `common_ratio_q1/q2` | 公共词在各自文本中的占比 | 分别考虑两个方向 |

### 3️⃣ 相似度特征（3个）

| 特征名 | 说明 | 计算方式 |
|--------|------|----------|
| `jaccard_similarity` | Jaccard相似度 | \|A∩B\| / \|A∪B\| |
| `cosine_similarity` | 余弦相似度 | 基于词频向量 |
| `edit_distance_normalized` | 归一化编辑距离 | 1 - (编辑距离/最大长度) |

### 4️⃣ 唯一性特征（2个）

| 特征名 | 说明 | 意义 |
|--------|------|------|
| `unique_words_q1` | 文本1的唯一词数 | 词汇丰富度 |
| `unique_words_q2` | 文本2的唯一词数 | 词汇丰富度 |

### 5️⃣ 词ID统计特征（6个）

| 特征名 | 说明 | 意义 |
|--------|------|------|
| `mean_word_id_q1/q2` | 平均词ID | 常用词vs生僻词 |
| `max_word_id_q1/q2` | 最大词ID | 包含的最生僻词 |
| `min_word_id_q1/q2` | 最小词ID | 包含的最常用词 |

---

## 🏗️ 模型架构

### 基线模型 vs 增强模型

```
┌─────────────────────────────────────────────────┐
│              基线模型（无特征工程）                  │
├─────────────────────────────────────────────────┤
│ Query1/Query2                                   │
│      ↓                                          │
│ Embedding + BiLSTM                              │
│      ↓                                          │
│ 交互层（Cosine + Element-wise）                  │
│      ↓                                          │
│ 全连接分类器                                     │
│      ↓                                          │
│ 输出（1537维 → 512 → 256 → 1）                  │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│         增强模型（含特征工程）✨                     │
├─────────────────────────────────────────────────┤
│ Query1/Query2                                   │
│      ↓                                          │
│ ┌─────────────────────┐   ┌──────────────────┐ │
│ │  深度学习特征分支     │   │  手工特征分支     │ │
│ │  • Embedding        │   │  • 长度特征      │ │
│ │  • BiLSTM          │   │  • 重叠特征      │ │
│ │  • 交互层           │   │  • 相似度特征    │ │
│ │  (1537维)          │   │  • 统计特征      │ │
│ │                    │   │  (19维 → 128     │ │
│ │                    │   │   → 64维)        │ │
│ └─────────────────────┘   └──────────────────┘ │
│              ↓                     ↓            │
│         特征融合（1537 + 64 = 1601维）           │
│                     ↓                           │
│      全连接分类器（1601 → 512 → 256 → 128 → 1）  │
│                     ↓                           │
│                   输出                           │
└─────────────────────────────────────────────────┘
```

---

## 🚀 使用方法

### 方法1：训练增强模型

```bash
cd /home/xinguanze/class/ml2

# 基础训练
python train_enhanced.py

# 或使用main程序
python main_enhanced.py --mode train
```

### 方法2：测试特征提取

```bash
# 测试特征提取器
python features.py

# 测试增强模型
python model_enhanced.py
```

### 方法3：对比基线和增强模型

```bash
# 先训练基线模型
python train.py

# 再训练增强模型
python train_enhanced.py

# 查看性能对比
```

---

## 📈 预期性能提升

| 模型 | AUC | 准确率 | F1 | 提升 |
|------|-----|--------|----|----|
| **基线模型** | 0.9718 | 0.9252 | 0.9029 | - |
| **增强模型** | 0.9730+ | 0.9260+ | 0.9040+ | +0.1~0.3% |

---

## 💡 特征工程的关键优势

### 1. **显式捕捉文本相似性**
```python
示例:
Q1: "1 2 3 4 5"
Q2: "3 4 5 6 7"

手工特征会明确计算:
- 重叠词数: 3 (词3, 4, 5)
- Jaccard相似度: 0.6 (3/5)
- 编辑距离: 4
```

### 2. **长度信息利用**
```python
示例:
Q1: "1 2"        (长度2)
Q2: "1 2 3 4 5"  (长度5)

特征:
- len_diff = 3 (差异较大)
- len_ratio = 0.4 (比例较小)
→ 更可能不匹配
```

### 3. **统计规律**
```python
常用词 (ID小) vs 生僻词 (ID大):
- mean_word_id: 反映文本的"常见度"
- 两个文本的词ID分布相似 → 可能表达类似意思
```

---

## 🔍 特征重要性分析

训练完成后，可以分析特征重要性：

```python
from features import FeatureExtractor

extractor = FeatureExtractor()
print("特征列表:")
for i, name in enumerate(extractor.feature_names):
    print(f"{i+1:2d}. {name}")
```

**通常最重要的特征**（按经验排序）:
1. `jaccard_similarity` ⭐⭐⭐⭐⭐
2. `word_overlap_ratio` ⭐⭐⭐⭐⭐
3. `cosine_similarity` ⭐⭐⭐⭐
4. `edit_distance_normalized` ⭐⭐⭐⭐
5. `len_ratio` ⭐⭐⭐

---

## 📊 输出文件

训练后会生成:
- ✅ `best_model_enhanced.pth` - 增强模型权重
- ✅ `training_history_enhanced.png` - 训练曲线
- ✅ 自动特征标准化参数（保存在模型中）

---

## 🎯 快速开始

```bash
# 1. 测试特征提取
python features.py

# 2. 训练增强模型（10个epoch）
python train_enhanced.py

# 3. 对比性能
echo "基线模型AUC: 0.9718"
grep "Best Val AUC" < terminal_output
```

---

## 🆚 何时使用哪个模型？

| 场景 | 推荐模型 | 原因 |
|------|---------|------|
| **快速原型** | 基线模型 | 更快，参数更少 |
| **追求性能** | 增强模型 | AUC更高 |
| **可解释性** | 增强模型 | 可以分析特征重要性 |
| **资源受限** | 基线模型 | 显存占用更小 |

---

**祝训练顺利！✨**
